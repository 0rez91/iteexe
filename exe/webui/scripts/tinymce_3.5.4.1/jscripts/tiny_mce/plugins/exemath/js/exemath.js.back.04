/* common.js */
function new_makeMathImage_viaTinyMCE(field_name, src_latex, font_size, type, win) {
	
	var w = "";
	if (typeof(top.nevow_clientToServerEvent)!='undefined') w = top;
	else {
		alert("TinyMCE's \u0022inlinepopups\u0022 plugin is required.");
		return;
	}
	
	var local_imagePath = ""

    if (src_latex == "") {
       return;
    }

    // to help unique-ify each previewed math image:
    var preview_basename = "eXe_LaTeX_math_"+w.curr_edits_math_num
    var preview_math_imagefile = preview_basename+".gif"
    // Simplify the subsequent file-lookup process,  by just appending 
    // the ".tex" to the full image name, as such:
    var preview_math_srcfile = preview_math_imagefile+".tex"
   
    w.curr_edits_math_num += 1

    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
    // pass the file information on to the server,
    // to generate the image into the server's "previews" directory:
	
	w.nevow_clientToServerEvent('generateTinyMCEmath', this, 
                  '', win, win.name, field_name, 
                  src_latex, font_size, preview_math_imagefile, 
                  preview_math_srcfile)

    // once the image has been generated, it SHOULD be sitting here:
    var full_preview_url = "/previews/"+preview_math_imagefile;
	
	win.focus();

    // clear out any old value in the tinyMCE image filename field:
    win.document.forms[0].elements[field_name].value = ""; 
    // PreviewImage is only available for images:
    if (type == "image") {
       win.showPreviewImage(" ");
    }
    // the above two commands are the only way to really 
    // ensure that we can trigger the onchange event below:

    // set the tinyMCE image filename field:
    win.document.forms[0].elements[field_name].value = full_preview_url;
    // then force its onchange event:
    // PreviewImage is only available for images:
    if (type == "image") {
       win.showPreviewImage(full_preview_url);
    }

}
/* Form utils */
function openBrower3(img_id, source_form_element, source2_form_element, target_form_element, type, option) {
	var img = document.getElementById(img_id);

	if (img.className != "mceButtonDisabled")
		openBrowser3(source_form_element, source2_form_element, target_form_element, type, option);
}
/* TinyMCE popup */
var openBrowser3 = function(src_element_id, src2_element_id, dst_element_id, type, option) {
	/*
	var cb = tinyMCE.getParam(option, tinyMCE.getParam("file_browser_callback"));
	var src_val = document.getElementById(src_element_id).value;
	var src2_val = document.getElementById(src2_element_id).value;

	tinyMCE.setWindowArg("window", window);
	tinyMCE.setWindowArg("document", document);

	// Call to external callback
	if (eval('typeof(tinyMCEPopup.windowOpener.' + cb + ')') == "undefined")
		alert("Callback function: " + cb + " could not be found.");
	else
		eval("tinyMCEPopup.windowOpener." + cb + "(dst_element_id, src_val, src2_val, type, window);");
		*/
	var src_val = document.getElementById(src_element_id).value;
	var src2_val = document.getElementById(src2_element_id).value;		
	new_makeMathImage_viaTinyMCE(dst_element_id, src_val, src2_val, type, window);		
}
	/*
	,
	
		openBrowser: function (a, c, b) {
		tinyMCEPopup.restoreSelection();
		this.editor.execCallback("file_browser_callback", a, document.getElementById(a).value, c, window)
	}
	*/

/* Functions for the advimage plugin popup */

var preloadImg = null;
var orgImageWidth, orgImageHeight;

function convertURL(url, node, on_save) {
	return eval("tinyMCEPopup.windowOpener." + tinyMCE.settings['urlconverter_callback'] + "(url, node, on_save);");
}

function getImageSrc(str) {
	var pos = -1;

	if (!str)
		return "";

	if ((pos = str.indexOf('this.src=')) != -1) {
		var src = str.substring(pos + 10);

		src = src.substring(0, src.indexOf('\''));

		if (tinyMCE.getParam('convert_urls'))
			src = convertURL(src, null, true);

		return src;
	}

	return "";
}


// setup the math browser callback:
function getMathBrowserHTML(id, source_form_element, font_size_element, target_form_element, type, prefix) {

		var html = "";

	html += '<CENTER>&nbsp;';
	html += '<BUTTON type=\"button\" name=\"PREVIEW\"';
        html += 'onclick="javascript:openBrower3(\'' + id + '\',\'' + source_form_element + '\',\'' + font_size_element + '\',\'' + target_form_element + '\', \'' + type + '\',\'' + prefix + '\');" ';
		//html += 'onclick="alert(\''+source_form_element+'\')" ';
	html += '>';
	///////
	// add the icon image into the button:
        html += '<img id="' + id + '" src="img/exemath.gif"';
        html += ' width="20" height="18" border="0" title="' + tinyMCEPopup.getLang('exemath.compile_tooltip') + '"';
        html += ' class="mceButtonNormal" alt="' + tinyMCEPopup.getLang('exemath.compile_tooltip') + '" />';
	///////
	html += "<BR>";
	html += tinyMCEPopup.getLang('exemath.compile_label');
	html += '</BUTTON><BR>';

	html += '</CENTER>';
	html += '</a>';

        return html;
} // getMathBrowserHTML()



// very similar to getMathBrowserHTML, but to actually perform the math-compiling callback right now:
function doMathBrowser(id, source_form_element, font_size_element, target_form_element, type, prefix) {
        var option = prefix + "_" + type + "_browser_callback";
        var cb = tinyMCE.getParam(option, tinyMCE.getParam("file_browser_callback"));
        if (cb == null)
                return "";

        var html = "";

        openBrower3(id, source_form_element, font_size_element, target_form_element, type, option );

        return html;
} // doMathBrowser()




function insertAction() {

	var prev = document.getElementById("prev");
	if (prev.innerHTML=='') {
		alert("Genera la imagen pulsando \u0022Previsualizar\u0022 antes de guardar");
		return;
	} else {
		var ed = tinyMCEPopup.editor, f = document.forms[0];
		//Insert and close
		var ed = tinyMCEPopup.editor, f = document.forms[0], nl = f.elements, v, args = {}, el;
		
		tinyMCEPopup.restoreSelection();
		
		// Fixes crash in Safari
		if (tinymce.isWebKit)
			ed.getWin().focus();

		if (!ed.settings.inline_styles) {
			args = {
				vspace : nl.vspace.value,
				hspace : nl.hspace.value,
				border : nl.border.value,
				align : getSelectValue(f, 'align')
			};
		} else {
			// Remove deprecated values
			args = {
				vspace : '',
				hspace : '',
				border : '',
				align : ''
			};
		}
		
		var exe_math_latex_src = nl.src.value.replace(/ /g, '%20')+".tex"
		//The path is /previews/... and eXe requires ../previews/...
		if (exe_math_latex_src.indexOf("/previews/")==0) exe_math_latex_src = ".."+exe_math_latex_src;

		tinymce.extend(args, {
			src : nl.src.value.replace(/ /g, '%20'),
			width : nl.width.value,
			height : nl.height.value,
			alt : nl.alt.value,
			'class' : getSelectValue(f, 'class_list'),
			exe_math_latex : exe_math_latex_src
		});
		
		args.onmouseover = args.onmouseout = '';
		
		el = ed.selection.getNode();
		
		if (el && el.nodeName == 'IMG') {
			ed.dom.setAttribs(el, args);
		} else {
			tinymce.each(args, function(value, name) {
				if (value === "") {
					delete args[name];
				}
			});

			ed.execCommand('mceInsertContent', false, tinyMCEPopup.editor.dom.createHTML('img', args), {skip_undo : 1});
			ed.undoManager.add();
		}
		
		tinyMCEPopup.editor.execCommand('mceRepaint');
		tinyMCEPopup.editor.focus();
		tinyMCEPopup.close();
		
	}
	
}





function updateStyle() {
	var formObj = document.forms[0];
	var st = tinyMCE.parseStyle(formObj.style.value);

	if (tinyMCE.getParam('inline_styles', false)) {
		st['width'] = formObj.width.value == '' ? '' : formObj.width.value + "px";
		st['height'] = formObj.height.value == '' ? '' : formObj.height.value + "px";
		st['border-width'] = formObj.border.value == '' ? '' : formObj.border.value + "px";
		st['margin-top'] = formObj.vspace.value == '' ? '' : formObj.vspace.value + "px";
		st['margin-bottom'] = formObj.vspace.value == '' ? '' : formObj.vspace.value + "px";
		st['margin-left'] = formObj.hspace.value == '' ? '' : formObj.hspace.value + "px";
		st['margin-right'] = formObj.hspace.value == '' ? '' : formObj.hspace.value + "px";
	} else {
		st['width'] = st['height'] = st['border-width'] = null;

		if (st['margin-top'] == st['margin-bottom'])
			st['margin-top'] = st['margin-bottom'] = null;

		if (st['margin-left'] == st['margin-right'])
			st['margin-left'] = st['margin-right'] = null;
	}

	formObj.style.value = tinyMCE.serializeStyle(st);
}

function styleUpdated() {
	var formObj = document.forms[0];
	var st = tinyMCE.parseStyle(formObj.style.value);

	if (st['width'])
		formObj.width.value = st['width'].replace('px', '');

	if (st['height'])
		formObj.height.value = st['height'].replace('px', '');

	if (st['margin-top'] && st['margin-top'] == st['margin-bottom'])
		formObj.vspace.value = st['margin-top'].replace('px', '');

	if (st['margin-left'] && st['margin-left'] == st['margin-right'])
		formObj.hspace.value = st['margin-left'].replace('px', '');

	if (st['border-width'])
		formObj.border.value = st['border-width'].replace('px', '');
}

function changeHeight() {
	var formObj = document.forms[0];

	if (!formObj.constrain.checked || !preloadImg) {
		updateStyle();
		return;
	}

	if (formObj.width.value == "" || formObj.height.value == "")
		return;

	var temp = (parseInt(formObj.width.value) / parseInt(preloadImg.width)) * preloadImg.height;
	formObj.height.value = temp.toFixed(0);
	updateStyle();
}

function changeWidth() {
	var formObj = document.forms[0];

	if (!formObj.constrain.checked || !preloadImg) {
		updateStyle();
		return;
	}

	if (formObj.width.value == "" || formObj.height.value == "")
		return;

	var temp = (parseInt(formObj.height.value) / parseInt(preloadImg.height)) * preloadImg.width;
	formObj.width.value = temp.toFixed(0);
	updateStyle();
}

function onSelectMainImage(target_form_element, name, value) {
	var formObj = document.forms[0];

	formObj.alt.value = name;
	formObj.title.value = name;

	resetImageData();
	showPreviewImage(formObj.elements[target_form_element].value, false);
}

function showPreviewImage(src, start) {

	var elm = document.getElementById('prev');
	if (src!="") {
		var formObj = document.forms[0]; 
		selectByValue(document.forms[0], 'imagelistsrc', src);
		elm.innerHTML = '<img id="previewImg" src="' + src + '" onload="updateImageData(' + start +', \'' + src + '\');" />'
	} else {
		elm.innerHTML = "";
	}
	
}

function updateImageData(start, src) {

	alert("updateImageData");

	var formObj = document.forms[0];

	preloadImg = document.getElementById('previewImg');

	if (!start && formObj.width.value == "")
		formObj.width.value = preloadImg.width;

	if (!start && formObj.height.value == "")
		formObj.height.value = preloadImg.height;

	updateStyle();

	if (src != "") {
	
		// this is an exemath image to preview, meaning that it should have its .tex at: 
		// resources/eXe_LaTeX_math_#.gif.tex or  ../previews/eXe_LaTeX_math_#.gif.tex
		// request the contents of that file, to update our LaTeX source field:

		var input_filename = src+".tex" 
		
		objXml = new XMLHttpRequest();
		objXml.open("GET",input_filename,false);
		objXml.send(null);
		
		var found_source = 1;
		if (objXml.responseText == "" || (objXml.responseText.substr(0,"<html>".length) == "<html>" && objXml.responseText.indexOf("404 - No Such Resource") >= 0 && objXml.responseText.indexOf("File not found") >= 0)) {
		   // then we can be pretty darned sure that it wasn't found :-)
		   found_source = 0;
		}

		if (found_source) {
		  latex_source_elem = document.getElementById('latex_source');
		  latex_source_elem.value = objXml.responseText;
		}
		else {
		  alert('Warning: no source math found in: ' + input_filename);
		}		
		
	}
}

function resetImageData() {
	var formObj = document.forms[0];
	formObj.width.value = formObj.height.value = "";	
}

function getSelectValue(form_obj, field_name) {
	var elm = form_obj.elements[field_name];

	if (elm == null || elm.options == null)
		return "";

	return elm.options[elm.selectedIndex].value;
}

function getImageListHTML(elm_id, target_form_element, onchange_func) {
	if (typeof(tinyMCEImageList) == "undefined" || tinyMCEImageList.length == 0)
		return "";

	var html = "";

	html += '<select id="' + elm_id + '" name="' + elm_id + '"';
	html += ' class="mceImageList" onfocus="tinyMCE.addSelectAccessibility(event, this, window);" onchange="this.form.' + target_form_element + '.value=';
	html += 'this.options[this.selectedIndex].value;';

	if (typeof(onchange_func) != "undefined")
		html += onchange_func + '(\'' + target_form_element + '\',this.options[this.selectedIndex].text,this.options[this.selectedIndex].value);';

	html += '"><option value="">---</option>';

	for (var i=0; i<tinyMCEImageList.length; i++)
		html += '<option value="' + tinyMCEImageList[i][1] + '">' + tinyMCEImageList[i][0] + '</option>';

	html += '</select>';

	return html;
}

//////////////////////////////////////
// insertAtCursor() and insertSymbol()
// both swiped straight from common.js,
// for the old maths idevice:

function insertAtCursor(myField, myValue, num) {
    //MOZILLA/NETSCAPE support

    if (myField.selectionStart || myField.selectionStart == '0') {
        var startPos = myField.selectionStart;
        var endPos = myField.selectionEnd;
        myField.value = myField.value.substring(0, startPos)
            + myValue
            + myField.value.substring(endPos, myField.value.length);
        myField.selectionStart = startPos + myValue.length - num
    } else {
        myField.value += myValue;
    }
    myField.selectionEnd = myField.selectionStart
    myField.focus();
}

function insertSymbol(id, string, num){
    var ele = document.getElementById(id);
    insertAtCursor(ele, string, num)
}

/* My plugin */








(function() {
	var url;

	function get(id) {
		return document.getElementById(id);
	}

	window.ExeMath = {
	
		init : function() {
			
			var html = getMathBrowserHTML('srcbrowser', 'latex_source', 'math_font_size', 'src','image','exemath');
			document.getElementById("srcbrowsercontainer").innerHTML = html;

			var f = document.forms[0]; 
			var nl = f.elements; 
			var ed = tinyMCEPopup.editor; 
			var dom = ed.dom; 
			var n = ed.selection.getNode();
			//var fl = tinyMCEPopup.getParam('external_image_list', 'tinyMCEImageList');

			if (n.nodeName == 'IMG') {
			
				nl.src.value = dom.getAttrib(n, 'src');
				nl.width.value = dom.getAttrib(n, 'width');
				nl.height.value = dom.getAttrib(n, 'height');
				nl.alt.value = dom.getAttrib(n, 'alt');
				//nl.title.value = dom.getAttrib(n, 'title');
				nl.vspace.value = this.getAttrib(n, 'vspace');
				nl.hspace.value = this.getAttrib(n, 'hspace');
				nl.border.value = this.getAttrib(n, 'border');
				selectByValue(f, 'align', this.getAttrib(n, 'align'));
				selectByValue(f, 'class_list', dom.getAttrib(n, 'class'), true, true);
				nl.style.value = dom.getAttrib(n, 'style');
				nl.insert.value = ed.getLang('update');
				
				if (ed.settings.inline_styles) {
					// Move attribs to styles
					if (dom.getAttrib(n, 'align'))
						this.updateStyle('align');

					if (dom.getAttrib(n, 'hspace'))
						this.updateStyle('hspace');

					if (dom.getAttrib(n, 'border'))
						this.updateStyle('border');

					if (dom.getAttrib(n, 'vspace'))
						this.updateStyle('vspace');
				}
			}
			
			this.changeAppearance();
			this.showPreviewImage(nl.src.value, 1);
			this.getLatexCode(nl.src.value);
			
		},
		
		getLatexCode : function(src) {
		
			if (src != "") {
				// this is an exemath image to preview, meaning that it should have its .tex at: 
				// resources/eXe_LaTeX_math_#.gif.tex or  ../previews/eXe_LaTeX_math_#.gif.tex
				// request the contents of that file, to update our LaTeX source field:

				var input_filename = src+".tex";
				
				var w = "";
				if (typeof(parent.exe_package_name)!='undefined') w = parent;
				if (w!="") {
					input_filename = "/"+w.exe_package_name+"/"+input_filename;
				}
				
				objXml = new XMLHttpRequest();
				objXml.open("GET",input_filename,false);
				objXml.send(null);

				var found_source = 1;
				if (objXml.responseText == "" || (objXml.responseText.substr(0,"<html>".length) == "<html>" && objXml.responseText.indexOf("404 - No Such Resource") >= 0 && objXml.responseText.indexOf("File not found") >= 0)) {
					// then we can be pretty darned sure that it wasn't found :-)
					found_source = 0;
				}

				if (found_source) {
					latex_source_elem = document.getElementById('latex_source');
					latex_source_elem.value = objXml.responseText;
				} else {
					alert('No source math found in: ' + input_filename);
				}
				
			}		
		
		},
		
		changeAppearance : function() {
		
			var ed = tinyMCEPopup.editor, f = document.forms[0], img = document.getElementById('alignSampleImg');

			if (img) {
				if (ed.getParam('inline_styles')) {
					ed.dom.setAttrib(img, 'style', f.style.value);
				} else {
					img.align = f.align.value;
					img.border = f.border.value;
					img.hspace = f.hspace.value;
					img.vspace = f.vspace.value;
				}
			}
		},

		showPreviewImage : function(u, st) {
		
			if (!u) {
				tinyMCEPopup.dom.setHTML('prev', '');
				return;
			}

			if (!st && tinyMCEPopup.getParam("advimage_update_dimensions_onchange", true))
				this.resetImageData();

			u = tinyMCEPopup.editor.documentBaseURI.toAbsolute(u);

			if (!st)
				tinyMCEPopup.dom.setHTML('prev', '<img id="previewImg" src="' + u + '" border="0" onload="ImageDialog.updateImageData(this);" onerror="ImageDialog.resetImageData();" />');
			else
				tinyMCEPopup.dom.setHTML('prev', '<img id="previewImg" src="' + u + '" border="0" onload="ImageDialog.updateImageData(this, 1);" />');
		},

		getAttrib : function(e, at) {
			var ed = tinyMCEPopup.editor, dom = ed.dom, v, v2;

			if (ed.settings.inline_styles) {
				switch (at) {
					case 'align':
						if (v = dom.getStyle(e, 'float'))
							return v;

						if (v = dom.getStyle(e, 'vertical-align'))
							return v;

						break;

					case 'hspace':
						v = dom.getStyle(e, 'margin-left')
						v2 = dom.getStyle(e, 'margin-right');

						if (v && v == v2)
							return parseInt(v.replace(/[^0-9]/g, ''));

						break;

					case 'vspace':
						v = dom.getStyle(e, 'margin-top')
						v2 = dom.getStyle(e, 'margin-bottom');
						if (v && v == v2)
							return parseInt(v.replace(/[^0-9]/g, ''));

						break;

					case 'border':
						v = 0;

						tinymce.each(['top', 'right', 'bottom', 'left'], function(sv) {
							sv = dom.getStyle(e, 'border-' + sv + '-width');

							// False or not the same as prev
							if (!sv || (sv != v && v !== 0)) {
								v = 0;
								return false;
							}

							if (sv)
								v = sv;
						});

						if (v)
							return parseInt(v.replace(/[^0-9]/g, ''));

						break;
				}
			}

			if (v = dom.getAttrib(e, at))
				return v;

			return '';
		}		
		
	};

	tinyMCEPopup.requireLangPack();
	
	tinyMCEPopup.onInit.add(function() {
		ExeMath.init();
	});
	
})();